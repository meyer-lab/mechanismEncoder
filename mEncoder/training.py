import numpy as np
import pandas as pd
import os
import fides
import logging
import scipy.linalg as la

from .autoencoder import MechanisticAutoEncoder

from pypesto.optimize import (
    FidesOptimizer, minimize, OptimizeOptions
)
from pypesto import Problem, Result
from pypesto.objective.aesara import AesaraObjective


basedir = os.path.dirname(os.path.dirname(__file__))
trace_path = os.path.join(basedir, 'traces')
TRACE_FILE_TEMPLATE = '{pathway}__{data}__{n_hidden}__{job}__{{id}}.csv'


def generate_pypesto_objective(
        ae: MechanisticAutoEncoder
) -> AesaraObjective:
    """
    Creates a pypesto objective function (this is the loss function) that
    needs to be minimized to train the respective autoencoder

    :param ae:
        Autoencoder that will be trained

    :returns:
        Objective function that needs to be minimized for training.
    """

    return AesaraObjective(
        ae.pypesto_subproblem.objective, ae.x, ae.model_pars
    )


def create_pypesto_problem(
        ae:  MechanisticAutoEncoder
) -> Problem:
    """
    Creates a pypesto problem that defines the optimization problem that
    needs to be solved for the training of the provided autoencoder

    :param ae:
        Autoencoder that will be trained

    :returns:
        Optimization problem that needs to be solved for training.
    """
    return Problem(
        objective=generate_pypesto_objective(ae),
        x_names=ae.x_names,
        lb=[-np.inf for _ in ae.x_names],
        ub=[np.inf for _ in ae.x_names],
    )


def train(ae: MechanisticAutoEncoder,
          samplestr: str,
          ftol: float = 1e-3,
          maxiter: int = 1e4,
          n_starts: int = 1,
          seed: int = 0) -> Result:
    """
    Trains the provided autoencoder by solving the optimization problem
    generated by :py:func:`create_pypesto_problem`

    :param ae:
        Autoencoder that will be trained
    :param ftol:
        function tolerance that is used to assess optimizer convergence
    :param maxiter:
        maximum number of optimization iterations
    :param n_starts:
        number of local starts that will be performed
    :param seed:
        random seed that will be used to generate the randomly sampled
        initial startpoints

    :returns:
        Pypesto optimization results.
    """
    pypesto_problem = create_pypesto_problem(ae)
    opt = FidesOptimizer(
        hessian_update=fides.BFGS(),
        options={
            'maxtime': 3600,
            fides.Options.FATOL: ftol,
            fides.Options.MAXTIME: 3600,
            fides.Options.MAXITER: maxiter,
            fides.Options.SUBSPACE_DIM: fides.SubSpaceDim.TWO
        },
        verbose=logging.INFO
    )

    np.random.seed(seed)

    optimize_options = OptimizeOptions(
        startpoint_resample=False,
        allow_failed_starts=True,
    )

    pca_pretraining = os.path.join(
        'pretraining', f'{ae.pathway_name}__{ae.data_name}__pca'
                       f'__{samplestr}__{ae.n_hidden}__{seed}.csv'
    )
    pretraining = pd.read_csv(pca_pretraining, index_col=0)

    w = np.expand_dims(la.lstsq(ae.data, ae.data_pca)[0].flatten(), 1)

    pypesto_problem.x_guesses_full = np.hstack([w.T, pretraining.values])

    return minimize(
        pypesto_problem,
        opt,
        n_starts=n_starts,
        options=optimize_options,
    )
