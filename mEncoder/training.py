import numpy as np
import pandas as pd
import os
import nlopt
import fides
import logging

from .autoencoder import MechanisticAutoEncoder, parameter_boundaries_scales

from pypesto.optimize import (
    IpoptOptimizer, NLoptOptimizer, FidesOptimizer,
    minimize, OptimizeOptions
)
from pypesto import Problem, HistoryOptions, Result, Objective

basedir = os.path.dirname(os.path.dirname(__file__))
trace_path = os.path.join(basedir, 'traces')
TRACE_FILE_TEMPLATE = '{pathway}__{data}__{optimizer}__{n_hidden}__{job}__' \
                    '{{id}}.csv'


def generate_pypesto_objective(
        ae: MechanisticAutoEncoder
) -> Objective:
    """
    Creates a pypesto objective function (this is the loss function) that
    needs to be minimized to train the respective autoencoder

    :param ae:
        Autoencoder that will be trained

    :returns:
        Objective function that needs to be minimized for training.
    """
    loss = ae.compile_loss()
    loss_grad = ae.compile_loss_grad()

    def fun(x: np.ndarray) -> float:
        encoder_pars = x[0:ae.n_encoder_pars]
        kinetic_pars = x[ae.n_encoder_pars:]
        return - float(loss(encoder_pars, kinetic_pars))

    def grad(x: np.ndarray) -> np.ndarray:
        encoder_pars = x[:ae.n_encoder_pars]
        kinetic_pars = x[ae.n_encoder_pars:]
        return - np.asarray(loss_grad(encoder_pars, kinetic_pars))

    return Objective(
        fun=fun, grad=grad,
    )


def create_pypesto_problem(
        ae:  MechanisticAutoEncoder
) -> Problem:
    """
    Creates a pypesto problem that defines the optimization problem that
    needs to be solved for the training of the provided autoencoder

    :param ae:
        Autoencoder that will be trained

    :returns:
        Optimization problem that needs to be solved for training.
    """
    return Problem(
        objective=generate_pypesto_objective(ae),
        x_names=ae.x_names,
        lb=[-np.inf for _ in ae.x_names],
        ub=[np.inf for _ in ae.x_names],
    )


def train(ae: MechanisticAutoEncoder,
          optimizer: str = 'fides',
          ftol: float = 1e-3,
          maxiter: int = 1e4,
          n_starts: int = 1,
          seed: int = 0) -> Result:
    """
    Trains the provided autoencoder by solving the optimization problem
    generated by :py:func:`create_pypesto_problem`

    :param ae:
        Autoencoder that will be trained
    :param optimizer:
        Optimizer string that specifies the optimizer that will be used
    :param ftol:
        function tolerance that is used to assess optimizer convergence
    :param maxiter:
        maximum number of optimization iterations
    :param n_starts:
        number of local starts that will be performed
    :param seed:
        random seed that will be used to generate the randomly sampled
        initial startpoints

    :returns:
        Pypesto optimization results.
    """
    pypesto_problem = create_pypesto_problem(ae)

    if optimizer == 'ipopt':
        opt = IpoptOptimizer(
            options={
                'maxiter': maxiter,
                'tol': ftol,
                'disp': 5,
            }
        )
    elif optimizer.startswith('NLOpt_'):
        opt = NLoptOptimizer(
            method=getattr(nlopt, optimizer.replace('NLOpt_', '')),
            options={
                'maxtime': 3600,

                'ftol_abs': ftol,
            }
        )
    elif optimizer == 'fides':
        opt = FidesOptimizer(
            hessian_update=fides.BFGS(),
            options={
                'maxtime': 3600,
                fides.Options.FATOL: ftol,
                fides.Options.MAXTIME: 3600,
                fides.Options.MAXITER: maxiter,
                fides.Options.SUBSPACE_DIM: fides.SubSpaceDim.FULL
            },
            verbose=logging.INFO
        )

    os.makedirs(trace_path, exist_ok=True)

    history_options = HistoryOptions(
        trace_record=True,
        trace_record_hess=False,
        trace_record_res=False,
        trace_record_sres=False,
        trace_record_schi2=False,
        storage_file=os.path.join(
            trace_path,
            TRACE_FILE_TEMPLATE.format(pathway=ae.pathway_name,
                                       data=ae.data_name,
                                       optimizer=optimizer,
                                       n_hidden=ae.n_hidden,
                                       job=seed)
        ),
        trace_save_iter=10
    )

    np.random.seed(seed)

    optimize_options = OptimizeOptions(
        startpoint_resample=False,
        allow_failed_starts=True,
    )

    decoder_par_pretraining = os.path.join(
        'pretraining', f'{ae.pathway_name}__{ae.data_name}__{ae.n_hidden}'
                       f'__decoder_inflate.csv'
    )
    has_decoder_par_pretraing = os.path.exists(decoder_par_pretraining)
    if has_decoder_par_pretraing:
        decoder_pars = pd.read_csv(decoder_par_pretraining)[
            ae.x_names
        ]

    lb = np.asarray([
        parameter_boundaries_scales[name.split('_')[-1]][0]
        for name in pypesto_problem.x_names
    ])
    ub = np.asarray([
        parameter_boundaries_scales[name.split('_')[-1]][1]
        for name in pypesto_problem.x_names
    ])

    def startpoint(**kwargs):

        if has_decoder_par_pretraing and seed < len(decoder_pars):
            xs = decoder_pars.iloc[seed, :]
        else:
            xs = np.random.random((kwargs['n_starts'],
                                   ae.n_encoder_pars + ae.n_kin_params)) \
                * (ub - lb) + lb
        return xs

    return minimize(
        pypesto_problem,
        opt,
        n_starts=n_starts,
        options=optimize_options,
        history_options=history_options,
        startpoint_method=startpoint
    )
